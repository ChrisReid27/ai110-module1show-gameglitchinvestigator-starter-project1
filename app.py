import random
import streamlit as st
from logic_utils import check_guess, parse_guess, get_range_for_difficulty, update_score

st.set_page_config(page_title="Glitchy Guesser", page_icon="ðŸŽ®")

st.title("ðŸŽ® Game Glitch Investigator")
st.caption("An AI-generated guessing game. Something is off.")

st.sidebar.header("Settings")

difficulty = st.sidebar.selectbox(
    "Difficulty",
    ["Easy", "Normal", "Hard"],
    index=1,
)

attempt_limit_map = {
    "Easy": 6,
    "Normal": 8,
    "Hard": 5,
}
attempt_limit = attempt_limit_map[difficulty]

low, high = get_range_for_difficulty(difficulty)

st.sidebar.caption(f"Range: {low} to {high}")
st.sidebar.caption(f"Attempts allowed: {attempt_limit}")

if "secret" not in st.session_state:
    st.session_state.secret = random.randint(low, high)

if "attempts" not in st.session_state: #FIXME: Logic broke here.
    st.session_state.attempts = 0 # FIX: Changed from 1 to 0 to count attempts correctly with Agent mode.

if "score" not in st.session_state:
    st.session_state.score = 0

if "status" not in st.session_state:
    st.session_state.status = "playing"

if "last_processed_guess" not in st.session_state:
    st.session_state.last_processed_guess = None

if "history" not in st.session_state:
    st.session_state.history = []

if "show_hint" not in st.session_state:
    st.session_state.show_hint = True

if "hint_message" not in st.session_state:
    st.session_state.hint_message = None

st.subheader("Make a guess")

st.info(
    f"Guess a number between {low} and {high}. " # Fix: Corrected range display to match difficulty settings.
    f"Attempts left: {attempt_limit - st.session_state.attempts}"
)

with st.expander("Developer Debug Info"):
    st.write("Secret:", st.session_state.secret)
    st.write("Attempts:", st.session_state.attempts)
    st.write("Score:", st.session_state.score)
    st.write("Difficulty:", difficulty)
    st.write("History:", st.session_state.history)

raw_guess = st.text_input( #FIXME: Logic broke here.
    "Enter your guess:",
    key=f"guess_input_{difficulty}",
    on_change=lambda: st.session_state.update({"submit_triggered": True}),
    # FIX: Enter key submits the guess the same as clicking the submit button.
)

col1, col2, col3 = st.columns(3)
with col1:
    submit = st.button("Submit Guess ðŸš€")
with col2:
    new_game = st.button("New Game ðŸ”")
with col3:
    st.session_state.show_hint = st.checkbox("Show hint", value=st.session_state.show_hint)

if new_game:
    st.session_state.attempts = 0
    st.session_state.secret = random.randint(low, high) #FIXME: Logic broke here. FIX: New secret generated within the correct range for each mode.
    st.session_state.status = "playing" #Fix: Added to reset game status on new game.
    st.session_state.history = []
    st.session_state.last_processed_guess = None
    st.success("New game started.")
    st.rerun()

if st.session_state.status != "playing":
    if st.session_state.status == "won":
        st.success("You already won. Start a new game to play again.")
    else:
        st.error("Game over. Start a new game to try again.")
    st.stop()

#FIXME: Logic broke here.
# Fix: Ensured that guesses are only processed once per submission to avoid duplicate processing.
# Agent also shifted indentation.
# Fix: Both button click and Enter key trigger submission and hints are shown regardless of submission method.
if (st.session_state.get("submit_triggered") or submit) and raw_guess:
    # Clear the submit_triggered flag first
    if st.session_state.get("submit_triggered"):
        st.session_state.submit_triggered = False
    
    # Prevent processing the same guess twice
    if raw_guess != st.session_state.last_processed_guess:
        st.session_state.last_processed_guess = raw_guess
        st.session_state.attempts += 1

        ok, guess_int, err = parse_guess(raw_guess)

        if not ok:
            st.session_state.history.append(raw_guess)
            st.error(err)
        else:
            st.session_state.history.append(guess_int)

            if st.session_state.attempts % 2 == 0:
                secret = str(st.session_state.secret)
            else:
                secret = st.session_state.secret

            outcome, message = check_guess(guess_int, secret)

            # Store hint message in session state
            if st.session_state.show_hint:
                st.session_state.hint_message = message
            else:
                st.session_state.hint_message = None

            st.session_state.score = update_score(
                current_score=st.session_state.score,
                outcome=outcome,
                attempt_number=st.session_state.attempts,
            )

            if outcome == "Win":
                st.balloons()
                st.session_state.status = "won"
                st.success(
                    f"You won! The secret was {st.session_state.secret}. "
                    f"Final score: {st.session_state.score}"
                )
            else:
                if st.session_state.attempts >= attempt_limit:
                    st.session_state.status = "lost"
                    st.error(
                        f"Out of attempts! "
                        f"The secret was {st.session_state.secret}. "
                        f"Score: {st.session_state.score}"
                    )

# Display hint message if available
if st.session_state.hint_message and st.session_state.status == "playing":
    st.warning(st.session_state.hint_message)

st.divider()
st.caption("Built by an AI that claims this code is production-ready.")
